// Code generated by MockGen. DO NOT EDIT.
// Source: idatabase.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	sql "database/sql"
	interfaces "github.com/SurgicalSteel/kvothe/interfaces"
	resources "github.com/SurgicalSteel/kvothe/resources"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	sqlx "github.com/jmoiron/sqlx"
)

// MockIDatabase is a mock of IDatabase interface.
type MockIDatabase struct {
	ctrl     *gomock.Controller
	recorder *MockIDatabaseMockRecorder
}

// MockIDatabaseMockRecorder is the mock recorder for MockIDatabase.
type MockIDatabaseMockRecorder struct {
	mock *MockIDatabase
}

// NewMockIDatabase creates a new mock instance.
func NewMockIDatabase(ctrl *gomock.Controller) *MockIDatabase {
	mock := &MockIDatabase{ctrl: ctrl}
	mock.recorder = &MockIDatabaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIDatabase) EXPECT() *MockIDatabaseMockRecorder {
	return m.recorder
}

// Begin mocks base method.
func (m *MockIDatabase) Begin() (interfaces.IDBTx, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Begin")
	ret0, _ := ret[0].(interfaces.IDBTx)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Begin indicates an expected call of Begin.
func (mr *MockIDatabaseMockRecorder) Begin() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Begin", reflect.TypeOf((*MockIDatabase)(nil).Begin))
}

// BeginTx mocks base method.
func (m *MockIDatabase) BeginTx() (*sqlx.Tx, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BeginTx")
	ret0, _ := ret[0].(*sqlx.Tx)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BeginTx indicates an expected call of BeginTx.
func (mr *MockIDatabaseMockRecorder) BeginTx() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeginTx", reflect.TypeOf((*MockIDatabase)(nil).BeginTx))
}

// Close mocks base method.
func (m *MockIDatabase) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close.
func (mr *MockIDatabaseMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockIDatabase)(nil).Close))
}

// Commit mocks base method.
func (m *MockIDatabase) Commit() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit")
	ret0, _ := ret[0].(error)
	return ret0
}

// Commit indicates an expected call of Commit.
func (mr *MockIDatabaseMockRecorder) Commit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockIDatabase)(nil).Commit))
}

// ConnectDB mocks base method.
func (m *MockIDatabase) ConnectDB(dbAccRead, dbAccWrite *resources.DBAccount) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ConnectDB", dbAccRead, dbAccWrite)
}

// ConnectDB indicates an expected call of ConnectDB.
func (mr *MockIDatabaseMockRecorder) ConnectDB(dbAccRead, dbAccWrite interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConnectDB", reflect.TypeOf((*MockIDatabase)(nil).ConnectDB), dbAccRead, dbAccWrite)
}

// DriverName mocks base method.
func (m *MockIDatabase) DriverName() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DriverName")
	ret0, _ := ret[0].(string)
	return ret0
}

// DriverName indicates an expected call of DriverName.
func (mr *MockIDatabaseMockRecorder) DriverName() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DriverName", reflect.TypeOf((*MockIDatabase)(nil).DriverName))
}

// Exec mocks base method.
func (m *MockIDatabase) Exec(query string, args ...interface{}) (sql.Result, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exec", varargs...)
	ret0, _ := ret[0].(sql.Result)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Exec indicates an expected call of Exec.
func (mr *MockIDatabaseMockRecorder) Exec(query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockIDatabase)(nil).Exec), varargs...)
}

// ExecContext mocks base method.
func (m *MockIDatabase) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExecContext", varargs...)
	ret0, _ := ret[0].(sql.Result)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecContext indicates an expected call of ExecContext.
func (mr *MockIDatabaseMockRecorder) ExecContext(ctx, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecContext", reflect.TypeOf((*MockIDatabase)(nil).ExecContext), varargs...)
}

// Get mocks base method.
func (m *MockIDatabase) Get(dest interface{}, query string, args ...interface{}) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{dest, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Get", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Get indicates an expected call of Get.
func (mr *MockIDatabaseMockRecorder) Get(dest, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{dest, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockIDatabase)(nil).Get), varargs...)
}

// GetContext mocks base method.
func (m *MockIDatabase) GetContext(ctx context.Context, dest interface{}, query string, args ...interface{}) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, dest, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetContext", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// GetContext indicates an expected call of GetContext.
func (mr *MockIDatabaseMockRecorder) GetContext(ctx, dest, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, dest, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetContext", reflect.TypeOf((*MockIDatabase)(nil).GetContext), varargs...)
}

// In mocks base method.
func (m *MockIDatabase) In(query string, params ...interface{}) (string, []interface{}, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{query}
	for _, a := range params {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "In", varargs...)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].([]interface{})
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// In indicates an expected call of In.
func (mr *MockIDatabaseMockRecorder) In(query interface{}, params ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{query}, params...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "In", reflect.TypeOf((*MockIDatabase)(nil).In), varargs...)
}

// Query mocks base method.
func (m *MockIDatabase) Query(query string, args ...interface{}) (*sql.Rows, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Query", varargs...)
	ret0, _ := ret[0].(*sql.Rows)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Query indicates an expected call of Query.
func (mr *MockIDatabaseMockRecorder) Query(query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockIDatabase)(nil).Query), varargs...)
}

// QueryContext mocks base method.
func (m *MockIDatabase) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryContext", varargs...)
	ret0, _ := ret[0].(*sql.Rows)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// QueryContext indicates an expected call of QueryContext.
func (mr *MockIDatabaseMockRecorder) QueryContext(ctx, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryContext", reflect.TypeOf((*MockIDatabase)(nil).QueryContext), varargs...)
}

// QueryRow mocks base method.
func (m *MockIDatabase) QueryRow(query string, args ...interface{}) *sql.Row {
	m.ctrl.T.Helper()
	varargs := []interface{}{query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryRow", varargs...)
	ret0, _ := ret[0].(*sql.Row)
	return ret0
}

// QueryRow indicates an expected call of QueryRow.
func (mr *MockIDatabaseMockRecorder) QueryRow(query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryRow", reflect.TypeOf((*MockIDatabase)(nil).QueryRow), varargs...)
}

// QueryRowSqlx mocks base method.
func (m *MockIDatabase) QueryRowSqlx(query string, args ...interface{}) *sqlx.Row {
	m.ctrl.T.Helper()
	varargs := []interface{}{query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryRowSqlx", varargs...)
	ret0, _ := ret[0].(*sqlx.Row)
	return ret0
}

// QueryRowSqlx indicates an expected call of QueryRowSqlx.
func (mr *MockIDatabaseMockRecorder) QueryRowSqlx(query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryRowSqlx", reflect.TypeOf((*MockIDatabase)(nil).QueryRowSqlx), varargs...)
}

// Queryx mocks base method.
func (m *MockIDatabase) Queryx(query string, args ...interface{}) (*sqlx.Rows, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Queryx", varargs...)
	ret0, _ := ret[0].(*sqlx.Rows)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Queryx indicates an expected call of Queryx.
func (mr *MockIDatabaseMockRecorder) Queryx(query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Queryx", reflect.TypeOf((*MockIDatabase)(nil).Queryx), varargs...)
}

// Rebind mocks base method.
func (m *MockIDatabase) Rebind(query string) string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rebind", query)
	ret0, _ := ret[0].(string)
	return ret0
}

// Rebind indicates an expected call of Rebind.
func (mr *MockIDatabaseMockRecorder) Rebind(query interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rebind", reflect.TypeOf((*MockIDatabase)(nil).Rebind), query)
}

// Rollback mocks base method.
func (m *MockIDatabase) Rollback() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rollback")
	ret0, _ := ret[0].(error)
	return ret0
}

// Rollback indicates an expected call of Rollback.
func (mr *MockIDatabaseMockRecorder) Rollback() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rollback", reflect.TypeOf((*MockIDatabase)(nil).Rollback))
}

// Select mocks base method.
func (m *MockIDatabase) Select(dest interface{}, query string, args ...interface{}) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{dest, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Select", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Select indicates an expected call of Select.
func (mr *MockIDatabaseMockRecorder) Select(dest, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{dest, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Select", reflect.TypeOf((*MockIDatabase)(nil).Select), varargs...)
}

// TransactionBlock mocks base method.
func (m *MockIDatabase) TransactionBlock(tx *sqlx.Tx, fc func(*sqlx.Tx) error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TransactionBlock", tx, fc)
	ret0, _ := ret[0].(error)
	return ret0
}

// TransactionBlock indicates an expected call of TransactionBlock.
func (mr *MockIDatabaseMockRecorder) TransactionBlock(tx, fc interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TransactionBlock", reflect.TypeOf((*MockIDatabase)(nil).TransactionBlock), tx, fc)
}

// MockIDatabaseTx is a mock of IDatabaseTx interface.
type MockIDatabaseTx struct {
	ctrl     *gomock.Controller
	recorder *MockIDatabaseTxMockRecorder
}

// MockIDatabaseTxMockRecorder is the mock recorder for MockIDatabaseTx.
type MockIDatabaseTxMockRecorder struct {
	mock *MockIDatabaseTx
}

// NewMockIDatabaseTx creates a new mock instance.
func NewMockIDatabaseTx(ctrl *gomock.Controller) *MockIDatabaseTx {
	mock := &MockIDatabaseTx{ctrl: ctrl}
	mock.recorder = &MockIDatabaseTxMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIDatabaseTx) EXPECT() *MockIDatabaseTxMockRecorder {
	return m.recorder
}

// BeginTx mocks base method.
func (m *MockIDatabaseTx) BeginTx() (*sqlx.Tx, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BeginTx")
	ret0, _ := ret[0].(*sqlx.Tx)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BeginTx indicates an expected call of BeginTx.
func (mr *MockIDatabaseTxMockRecorder) BeginTx() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeginTx", reflect.TypeOf((*MockIDatabaseTx)(nil).BeginTx))
}

// TransactionBlock mocks base method.
func (m *MockIDatabaseTx) TransactionBlock(tx *sqlx.Tx, fc func(*sqlx.Tx) error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TransactionBlock", tx, fc)
	ret0, _ := ret[0].(error)
	return ret0
}

// TransactionBlock indicates an expected call of TransactionBlock.
func (mr *MockIDatabaseTxMockRecorder) TransactionBlock(tx, fc interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TransactionBlock", reflect.TypeOf((*MockIDatabaseTx)(nil).TransactionBlock), tx, fc)
}

// MockIDBTx is a mock of IDBTx interface.
type MockIDBTx struct {
	ctrl     *gomock.Controller
	recorder *MockIDBTxMockRecorder
}

// MockIDBTxMockRecorder is the mock recorder for MockIDBTx.
type MockIDBTxMockRecorder struct {
	mock *MockIDBTx
}

// NewMockIDBTx creates a new mock instance.
func NewMockIDBTx(ctrl *gomock.Controller) *MockIDBTx {
	mock := &MockIDBTx{ctrl: ctrl}
	mock.recorder = &MockIDBTxMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIDBTx) EXPECT() *MockIDBTxMockRecorder {
	return m.recorder
}

// Commit mocks base method.
func (m *MockIDBTx) Commit() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Commit")
}

// Commit indicates an expected call of Commit.
func (mr *MockIDBTxMockRecorder) Commit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockIDBTx)(nil).Commit))
}

// Rollback mocks base method.
func (m *MockIDBTx) Rollback() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Rollback")
}

// Rollback indicates an expected call of Rollback.
func (mr *MockIDBTxMockRecorder) Rollback() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rollback", reflect.TypeOf((*MockIDBTx)(nil).Rollback))
}

// MockIRows is a mock of IRows interface.
type MockIRows struct {
	ctrl     *gomock.Controller
	recorder *MockIRowsMockRecorder
}

// MockIRowsMockRecorder is the mock recorder for MockIRows.
type MockIRowsMockRecorder struct {
	mock *MockIRows
}

// NewMockIRows creates a new mock instance.
func NewMockIRows(ctrl *gomock.Controller) *MockIRows {
	mock := &MockIRows{ctrl: ctrl}
	mock.recorder = &MockIRowsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIRows) EXPECT() *MockIRowsMockRecorder {
	return m.recorder
}

// MapScan mocks base method.
func (m *MockIRows) MapScan(dest map[string]interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MapScan", dest)
	ret0, _ := ret[0].(error)
	return ret0
}

// MapScan indicates an expected call of MapScan.
func (mr *MockIRowsMockRecorder) MapScan(dest interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MapScan", reflect.TypeOf((*MockIRows)(nil).MapScan), dest)
}

// Next mocks base method.
func (m *MockIRows) Next() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Next")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Next indicates an expected call of Next.
func (mr *MockIRowsMockRecorder) Next() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Next", reflect.TypeOf((*MockIRows)(nil).Next))
}

// SliceScan mocks base method.
func (m *MockIRows) SliceScan() ([]interface{}, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SliceScan")
	ret0, _ := ret[0].([]interface{})
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SliceScan indicates an expected call of SliceScan.
func (mr *MockIRowsMockRecorder) SliceScan() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SliceScan", reflect.TypeOf((*MockIRows)(nil).SliceScan))
}

// StructScan mocks base method.
func (m *MockIRows) StructScan(dest interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StructScan", dest)
	ret0, _ := ret[0].(error)
	return ret0
}

// StructScan indicates an expected call of StructScan.
func (mr *MockIRowsMockRecorder) StructScan(dest interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StructScan", reflect.TypeOf((*MockIRows)(nil).StructScan), dest)
}
